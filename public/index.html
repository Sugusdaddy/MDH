<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MDH — Million Dollar Homepage</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Space+Mono&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #e8e8e8;
            --surface: #d8d8d8;
            --border: #c0c0c0;
            --text: #000000;
            --text-secondary: #666;
            --accent: #000;
            --green: #00aa00;
            --canvas-bg: #000000;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Space Grotesk', system-ui, sans-serif;
            min-height: 100vh;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 40px;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
        }

        .logo {
            font-size: 1.2rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .logo span {
            color: var(--green);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stats-mini {
            display: flex;
            gap: 25px;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .stats-mini strong {
            color: var(--text);
        }

        .btn-connect {
            background: var(--text);
            color: var(--bg);
            border: none;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-connect:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn-connect.connected {
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
        }

        /* Main Layout */
        .main {
            display: grid;
            grid-template-columns: 1fr 320px;
            min-height: calc(100vh - 73px);
        }

        @media (max-width: 900px) {
            .main {
                grid-template-columns: 1fr;
            }
        }

        /* Canvas Area */
        .canvas-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            background: var(--surface);
        }

        .canvas-container {
            position: relative;
            border: 2px solid var(--canvas-bg);
            background: var(--canvas-bg);
        }

        #pixelCanvas {
            display: block;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .canvas-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-top: 15px;
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            border-color: var(--text-secondary);
        }

        /* Sidebar */
        .sidebar {
            border-left: 1px solid var(--border);
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .section-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }

        /* Color Picker */
        .color-section {
            display: flex;
            flex-direction: column;
        }

        .color-display {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .color-preview {
            width: 50px;
            height: 50px;
            border: 1px solid var(--border);
            cursor: pointer;
            position: relative;
        }

        .color-preview input {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .color-hex {
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }

        .color-swatch {
            aspect-ratio: 1;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.15s;
        }

        .color-swatch:hover {
            transform: scale(1.15);
            z-index: 1;
        }

        .color-swatch.active {
            border-color: var(--text);
            box-shadow: 0 0 0 2px var(--bg), 0 0 0 3px var(--text);
        }

        /* Selected Pixel */
        .selection-section {
            background: var(--bg);
            padding: 20px;
            border: 1px solid var(--border);
        }

        .selection-empty {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .selection-coords {
            font-family: 'Space Mono', monospace;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .selection-cost {
            margin-top: 10px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .selection-cost strong {
            color: var(--green);
        }

        /* Paint Button */
        .btn-paint {
            width: 100%;
            padding: 18px;
            background: var(--green);
            color: var(--bg);
            border: none;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-paint:hover:not(:disabled) {
            filter: brightness(1.1);
        }

        .btn-paint:disabled {
            background: var(--border);
            color: var(--text-secondary);
            cursor: not-allowed;
        }

        /* Info */
        .info-section {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        .info-row span:first-child {
            color: var(--text-secondary);
        }

        .info-row span:last-child {
            font-family: 'Space Mono', monospace;
        }

        /* Wallet Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--surface);
            border: 1px solid var(--border);
            padding: 30px;
            width: 90%;
            max-width: 380px;
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 25px;
        }

        .wallet-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .wallet-option {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: var(--bg);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.15s;
        }

        .wallet-option:hover {
            border-color: var(--text-secondary);
        }

        .wallet-option img {
            width: 32px;
            height: 32px;
            border-radius: 6px;
        }

        .wallet-option .wallet-name {
            font-weight: 500;
        }

        .wallet-option .wallet-status {
            margin-left: auto;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .wallet-option .wallet-status.detected {
            color: var(--green);
        }

        .modal-close {
            margin-top: 20px;
            width: 100%;
            padding: 12px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
            font-family: inherit;
            cursor: pointer;
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255,255,255,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 2000;
        }

        .loading-overlay.show {
            display: flex;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 2px solid var(--border);
            border-top-color: var(--green);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 15px 25px;
            background: var(--surface);
            border: 1px solid var(--border);
            font-size: 0.85rem;
            z-index: 3000;
            transition: transform 0.3s;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        .toast.success {
            border-color: var(--green);
        }

        .toast.error {
            border-color: #ff4444;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">MDH<span>.</span></div>
        <div class="header-right">
            <div class="stats-mini">
                <span><strong id="statPixels">0</strong> painted</span>
                <span><strong id="statBurned">0</strong> burned</span>
            </div>
            <button class="btn-connect" id="connectBtn" onclick="openWalletModal()">
                Connect
            </button>
        </div>
    </header>

    <main class="main">
        <section class="canvas-section">
            <div class="canvas-container">
                <canvas id="pixelCanvas"></canvas>
            </div>
            <div class="canvas-info">
                <span id="coordsDisplay">X: 0 Y: 0</span>
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="zoomOut()">−</button>
                    <span id="zoomLevel">1×</span>
                    <button class="zoom-btn" onclick="zoomIn()">+</button>
                </div>
            </div>
        </section>

        <aside class="sidebar">
            <div class="color-section">
                <div class="section-title">Color</div>
                <div class="color-display">
                    <div class="color-preview" id="colorPreview" style="background: #00ff00;">
                        <input type="color" id="colorPicker" value="#00ff00">
                    </div>
                    <span class="color-hex" id="colorHex">#00ff00</span>
                </div>
                <div class="color-grid" id="colorGrid"></div>
            </div>

            <div class="selection-section">
                <div class="section-title">Selected</div>
                <div id="selectionContent">
                    <div class="selection-empty">Click a pixel to select</div>
                </div>
            </div>

            <button class="btn-paint" id="paintBtn" onclick="paintPixel()" disabled>
                Paint Pixel
            </button>

            <div class="info-section">
                <div class="section-title">Info</div>
                <div class="info-row">
                    <span>Canvas</span>
                    <span>500 × 500</span>
                </div>
                <div class="info-row">
                    <span>Cost</span>
                    <span>10,000 $MDH</span>
                </div>
                <div class="info-row">
                    <span>Total Supply</span>
                    <span>1,000,000,000</span>
                </div>
                <div class="info-row">
                    <span>Contract</span>
                    <span style="font-size: 0.7rem;">Atu...BAGS</span>
                </div>
            </div>
        </aside>
    </main>

    <!-- Wallet Modal -->
    <div class="modal-overlay" id="walletModal">
        <div class="modal">
            <div class="modal-title">Connect Wallet</div>
            <div class="wallet-list" id="walletList"></div>
            <button class="modal-close" onclick="closeWalletModal()">Cancel</button>
        </div>
    </div>

    <!-- Loading -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Processing...</div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script>
        // ═══════════════════════════════════════════
        // CONFIG
        // ═══════════════════════════════════════════
        const CONFIG = {
            CANVAS_SIZE: 500,
            TOKEN_MINT: 'AtuZNNV27hs3AjTf5dLMyxftsnqdv8DpmJWCmEimBAGS',
            COST_PER_PIXEL: 10000,
            TOKEN_DECIMALS: 9,
            RPC_URL: 'https://mainnet.helius-rpc.com/?api-key=d3e130a0-6d2c-4b0e-9175-45f3a3cda97b',
            // Supabase config
            SUPABASE_URL: 'https://vcusibvemhvrnntqbzew.supabase.co',
            SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZjdXNpYnZlbWh2cm5udHFiemV3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1NDU0NTAsImV4cCI6MjA4NjEyMTQ1MH0.oF06DWIEn7UDQ7a9zYzDX3T9r71EfUJQdNaX7TjRVdw'
        };
        
        // Initialize Supabase (with fallback)
        let db = null;
        try {
            if (CONFIG.SUPABASE_URL !== 'YOUR_SUPABASE_URL' && window.supabase) {
                db = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);
                console.log('Supabase initialized');
            }
        } catch (e) {
            console.warn('Supabase init failed, using localStorage:', e);
            db = null;
        }

        // ═══════════════════════════════════════════
        // STATE
        // ═══════════════════════════════════════════
        let canvasState = new Array(CONFIG.CANVAS_SIZE * CONFIG.CANVAS_SIZE).fill('#000000');
        let selectedPixels = []; // Array of {x, y}
        let selectedColor = '#00ff00';
        let zoomLevel = 1;
        let walletConnected = false;
        let walletPublicKey = null;
        let walletProvider = null;
        let connection = null;
        let stats = { pixelsPainted: 0, tokensBurned: 0 };
        let isSelecting = false;
        let selectionStart = null;

        // ═══════════════════════════════════════════
        // WALLETS CONFIG
        // ═══════════════════════════════════════════
        const WALLETS = [
            {
                name: 'Phantom',
                icon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiBmaWxsPSJub25lIj48cmVjdCB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgZmlsbD0iIzU1M0M5QSIgcng9IjY0Ii8+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTExMC40IDY0LjJjMCAxOC0xNC41IDMyLjYtMzIuNSAzMi42aC00LjRhNi42IDYuNiAwIDAgMS02LjYtNi42di0uNWMwLTMgMi40LTUuNSA1LjQtNS42aDUuNWMxMi4yIDAgMjIuMS05LjkgMjIuMS0yMi4xIDAtMTIuMi05LjktMjIuMS0yMi4xLTIyLjFIMzkuMmMtLjMgMC0uNS4yLS41LjV2NDYuM2MwIDMuNi0yLjkgNi42LTYuNiA2LjZoLS40Yy0zLjYgMC02LjYtMy02LjYtNi42VjQwLjJjMC0zLjYgMy02LjYgNi42LTYuNmg0Ni4yYzE4IDAgMzIuNSAxNC42IDMyLjUgMzIuNloiLz48Y2lyY2xlIGN4PSI0Ni4zIiBjeT0iNjQuMiIgcj0iNi42IiBmaWxsPSIjZmZmIi8+PGNpcmNsZSBjeD0iNjkuMiIgY3k9IjY0LjIiIHI9IjYuNiIgZmlsbD0iI2ZmZiIvPjwvc3ZnPg==',
                detect: () => window.phantom?.solana?.isPhantom,
                provider: () => window.phantom?.solana
            },
            {
                name: 'Solflare',
                icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHJ4PSIyNCIgZmlsbD0iIzFBMUExQSIvPjxwYXRoIGQ9Ik05NiA2NEw2NCAzMkwzMiA2NEw2NCA5Nkw5NiA2NFoiIGZpbGw9IiNGQzgwMUQiLz48L3N2Zz4=',
                detect: () => window.solflare?.isSolflare || window.solflare,
                provider: () => window.solflare
            },
            {
                name: 'Backpack',
                icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHJ4PSIyNCIgZmlsbD0iI0U0M0QzRCIvPjxwYXRoIGQ9Ik00MCA0OEg4OFY4MEg0MFY0OFoiIGZpbGw9IndoaXRlIi8+PC9zdmc+',
                detect: () => window.backpack?.isBackpack,
                provider: () => window.backpack
            },
            {
                name: 'Glow',
                icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHJ4PSIyNCIgZmlsbD0iIzVDNkJDMCIvPjxjaXJjbGUgY3g9IjY0IiBjeT0iNjQiIHI9IjMyIiBmaWxsPSJ3aGl0ZSIvPjwvc3ZnPg==',
                detect: () => window.glowSolana,
                provider: () => window.glowSolana
            },
            {
                name: 'Trust Wallet',
                icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHJ4PSIyNCIgZmlsbD0iIzMzNzVCQiIvPjxwYXRoIGQ9Ik02NCAzMkw5NiA0OFY4MEw2NCA5NkwzMiA4MFY0OEw2NCAzMloiIGZpbGw9IndoaXRlIi8+PC9zdmc+',
                detect: () => window.trustwallet?.solana,
                provider: () => window.trustwallet?.solana
            },
            {
                name: 'Coinbase',
                icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHJ4PSIyNCIgZmlsbD0iIzAwNTJGRiIvPjxjaXJjbGUgY3g9IjY0IiBjeT0iNjQiIHI9IjMyIiBmaWxsPSJ3aGl0ZSIvPjwvc3ZnPg==',
                detect: () => window.coinbaseSolana,
                provider: () => window.coinbaseSolana
            }
        ];

        // Colors
        const PRESET_COLORS = [
            '#ffffff', '#c0c0c0', '#808080', '#000000',
            '#ff0000', '#800000', '#ffff00', '#808000',
            '#00ff00', '#008000', '#00ffff', '#008080',
            '#0000ff', '#000080', '#ff00ff', '#800080'
        ];

        // ═══════════════════════════════════════════
        // INIT
        // ═══════════════════════════════════════════
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                connection = new solanaWeb3.Connection(CONFIG.RPC_URL, 'confirmed');
            } catch (e) {
                console.error('RPC connection failed:', e);
            }
            
            initCanvas();
            initColors();
            initWalletList();
            
            try {
                await loadCanvasState();
            } catch (e) {
                console.error('Load canvas failed:', e);
            }
            
            setupRealtimeUpdates();
        });

        function initCanvas() {
            const canvas = document.getElementById('pixelCanvas');
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / zoomLevel);
                const y = Math.floor((e.clientY - rect.top) / zoomLevel);
                if (x >= 0 && x < CONFIG.CANVAS_SIZE && y >= 0 && y < CONFIG.CANVAS_SIZE) {
                    document.getElementById('coordsDisplay').textContent = `X: ${x} Y: ${y} | Selected: ${selectedPixels.length}`;
                    
                    // If dragging, add pixels to selection
                    if (isSelecting && selectionStart) {
                        updateDragSelection(selectionStart.x, selectionStart.y, x, y);
                    }
                }
            });

            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / zoomLevel);
                const y = Math.floor((e.clientY - rect.top) / zoomLevel);
                if (x >= 0 && x < CONFIG.CANVAS_SIZE && y >= 0 && y < CONFIG.CANVAS_SIZE) {
                    isSelecting = true;
                    selectionStart = { x, y };
                    
                    // If not holding shift, clear previous selection
                    if (!e.shiftKey) {
                        selectedPixels = [];
                    }
                    
                    togglePixelSelection(x, y);
                    renderCanvas();
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                isSelecting = false;
                selectionStart = null;
                updateSelectionUI();
            });

            canvas.addEventListener('mouseleave', () => {
                isSelecting = false;
                selectionStart = null;
            });

            renderCanvas();
        }
        
        function isPixelPainted(x, y) {
            const color = canvasState[y * CONFIG.CANVAS_SIZE + x];
            return color && color !== '#000000';
        }
        
        function togglePixelSelection(x, y) {
            // Don't allow selecting already painted pixels
            if (isPixelPainted(x, y)) {
                showToast('Pixel already painted!', 'error');
                return;
            }
            
            const idx = selectedPixels.findIndex(p => p.x === x && p.y === y);
            if (idx === -1) {
                selectedPixels.push({ x, y });
            }
        }
        
        function updateDragSelection(x1, y1, x2, y2) {
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minY = Math.min(y1, y2);
            const maxY = Math.max(y1, y2);
            
            // Clear and add all unpainted pixels in rectangle
            selectedPixels = [];
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    if (!isPixelPainted(x, y)) {
                        selectedPixels.push({ x, y });
                    }
                }
            }
            renderCanvas();
        }
        
        function updateSelectionUI() {
            const count = selectedPixels.length;
            const cost = count * CONFIG.COST_PER_PIXEL;
            
            if (count === 0) {
                document.getElementById('selectionContent').innerHTML = 
                    '<div class="selection-empty">Click or drag to select pixels</div>';
                document.getElementById('paintBtn').disabled = true;
            } else {
                document.getElementById('selectionContent').innerHTML = `
                    <div class="selection-coords">${count} pixel${count > 1 ? 's' : ''}</div>
                    <div class="selection-cost">Cost: <strong>${cost.toLocaleString()} $MDH</strong></div>
                `;
                document.getElementById('paintBtn').disabled = !walletConnected;
            }
        }

        function initColors() {
            const grid = document.getElementById('colorGrid');
            const picker = document.getElementById('colorPicker');
            const preview = document.getElementById('colorPreview');
            const hex = document.getElementById('colorHex');

            PRESET_COLORS.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch' + (color === selectedColor ? ' active' : '');
                swatch.style.background = color;
                swatch.onclick = () => selectColor(color);
                grid.appendChild(swatch);
            });

            picker.addEventListener('input', (e) => selectColor(e.target.value));
        }

        function selectColor(color) {
            selectedColor = color;
            document.getElementById('colorPreview').style.background = color;
            document.getElementById('colorPicker').value = color;
            document.getElementById('colorHex').textContent = color;
            
            document.querySelectorAll('.color-swatch').forEach(s => {
                s.classList.toggle('active', s.style.background === color || 
                    rgbToHex(s.style.background) === color.toLowerCase());
            });
        }

        function rgbToHex(rgb) {
            if (rgb.startsWith('#')) return rgb.toLowerCase();
            const match = rgb.match(/\d+/g);
            if (!match) return rgb;
            return '#' + match.slice(0,3).map(x => parseInt(x).toString(16).padStart(2,'0')).join('');
        }

        function initWalletList() {
            const list = document.getElementById('walletList');
            list.innerHTML = '';

            WALLETS.forEach(wallet => {
                const detected = wallet.detect();
                const option = document.createElement('div');
                option.className = 'wallet-option';
                option.innerHTML = `
                    <img src="${wallet.icon}" alt="${wallet.name}" onerror="this.style.display='none'">
                    <span class="wallet-name">${wallet.name}</span>
                    <span class="wallet-status ${detected ? 'detected' : ''}">${detected ? 'Detected' : 'Not installed'}</span>
                `;
                if (detected) {
                    option.onclick = () => connectWallet(wallet);
                } else {
                    option.style.opacity = '0.5';
                    option.style.cursor = 'default';
                }
                list.appendChild(option);
            });
        }

        // ═══════════════════════════════════════════
        // WALLET
        // ═══════════════════════════════════════════
        function openWalletModal() {
            if (walletConnected) {
                disconnectWallet();
                return;
            }
            initWalletList();
            document.getElementById('walletModal').classList.add('show');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.remove('show');
        }

        async function connectWallet(wallet) {
            try {
                closeWalletModal();
                showLoading('Connecting...');

                walletProvider = wallet.provider();
                
                if (!walletProvider) {
                    throw new Error('Wallet provider not found');
                }

                // Try to connect
                let pubKey = null;

                // Check if already connected
                if (walletProvider.publicKey) {
                    pubKey = walletProvider.publicKey;
                } else if (walletProvider.isConnected && walletProvider.publicKey) {
                    pubKey = walletProvider.publicKey;
                } else {
                    // Need to connect
                    try {
                        const resp = await walletProvider.connect();
                        // Different wallets return publicKey differently
                        pubKey = resp?.publicKey || walletProvider.publicKey;
                    } catch (connectErr) {
                        // Some wallets throw if already connected, check publicKey
                        if (walletProvider.publicKey) {
                            pubKey = walletProvider.publicKey;
                        } else {
                            throw connectErr;
                        }
                    }
                }

                if (!pubKey) {
                    throw new Error('Could not get public key from wallet');
                }

                walletPublicKey = pubKey;
                walletConnected = true;

                const btn = document.getElementById('connectBtn');
                btn.classList.add('connected');
                
                const pubKeyStr = walletPublicKey.toString();
                btn.textContent = `${pubKeyStr.slice(0, 4)}...${pubKeyStr.slice(-4)}`;

                if (selectedPixels.length > 0) {
                    document.getElementById('paintBtn').disabled = false;
                }

                hideLoading();
                showToast('Connected', 'success');
                console.log('Wallet connected:', pubKeyStr);
                
            } catch (err) {
                console.error('Wallet connection error:', err);
                hideLoading();
                showToast(err.message || 'Connection failed', 'error');
            }
        }

        function disconnectWallet() {
            if (walletProvider?.disconnect) {
                walletProvider.disconnect();
            }
            walletConnected = false;
            walletPublicKey = null;
            walletProvider = null;

            const btn = document.getElementById('connectBtn');
            btn.classList.remove('connected');
            btn.textContent = 'Connect';
            document.getElementById('paintBtn').disabled = true;

            showToast('Disconnected', 'success');
        }

        // ═══════════════════════════════════════════
        // CANVAS
        // ═══════════════════════════════════════════
        function renderCanvas() {
            const canvas = document.getElementById('pixelCanvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = CONFIG.CANVAS_SIZE * zoomLevel;
            canvas.height = CONFIG.CANVAS_SIZE * zoomLevel;

            for (let y = 0; y < CONFIG.CANVAS_SIZE; y++) {
                for (let x = 0; x < CONFIG.CANVAS_SIZE; x++) {
                    ctx.fillStyle = canvasState[y * CONFIG.CANVAS_SIZE + x];
                    ctx.fillRect(x * zoomLevel, y * zoomLevel, zoomLevel, zoomLevel);
                }
            }

            // Grid
            if (zoomLevel >= 4) {
                ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx.lineWidth = 0.5;
                for (let i = 0; i <= CONFIG.CANVAS_SIZE; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * zoomLevel, 0);
                    ctx.lineTo(i * zoomLevel, canvas.height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, i * zoomLevel);
                    ctx.lineTo(canvas.width, i * zoomLevel);
                    ctx.stroke();
                }
            }

            // Selection highlight - draw all selected pixels
            if (selectedPixels.length > 0) {
                ctx.fillStyle = selectedColor;
                ctx.globalAlpha = 0.5;
                selectedPixels.forEach(p => {
                    ctx.fillRect(p.x * zoomLevel, p.y * zoomLevel, zoomLevel, zoomLevel);
                });
                ctx.globalAlpha = 1;
                
                // Border around selection
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                selectedPixels.forEach(p => {
                    ctx.strokeRect(p.x * zoomLevel, p.y * zoomLevel, zoomLevel, zoomLevel);
                });
            }

            document.getElementById('zoomLevel').textContent = `${zoomLevel}×`;
        }
        
        function clearSelection() {
            selectedPixels = [];
            updateSelectionUI();
            renderCanvas();
        }

        function zoomIn() {
            if (zoomLevel < 5) { zoomLevel++; renderCanvas(); }
        }

        function zoomOut() {
            if (zoomLevel > 1) { zoomLevel--; renderCanvas(); }
        }

        // ═══════════════════════════════════════════
        // PAINT
        // ═══════════════════════════════════════════
        async function paintPixel() {
            if (!walletConnected || selectedPixels.length === 0) return;

            // Filter out any already painted pixels (double check)
            const availablePixels = selectedPixels.filter(p => !isPixelPainted(p.x, p.y));
            
            if (availablePixels.length === 0) {
                showToast('All selected pixels are already painted!', 'error');
                selectedPixels = [];
                updateSelectionUI();
                renderCanvas();
                return;
            }
            
            if (availablePixels.length !== selectedPixels.length) {
                showToast(`${selectedPixels.length - availablePixels.length} pixels already painted, painting ${availablePixels.length}`, 'info');
                selectedPixels = availablePixels;
            }

            const pixelCount = selectedPixels.length;
            const totalCost = pixelCount * CONFIG.COST_PER_PIXEL;
            
            showLoading(`Preparing transaction for ${pixelCount} pixel${pixelCount > 1 ? 's' : ''}...`);

            try {
                const mintPubkey = new solanaWeb3.PublicKey(CONFIG.TOKEN_MINT);
                
                const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
                    walletPublicKey,
                    { mint: mintPubkey }
                );

                if (tokenAccounts.value.length === 0) {
                    hideLoading();
                    showToast('No $MDH tokens found', 'error');
                    return;
                }

                const tokenAccount = tokenAccounts.value[0];
                const balance = tokenAccount.account.data.parsed.info.tokenAmount.uiAmount;

                if (balance < totalCost) {
                    hideLoading();
                    showToast(`Need ${totalCost.toLocaleString()} $MDH (you have ${balance.toLocaleString()})`, 'error');
                    return;
                }

                showLoading('Creating burn transaction...');

                // Burn total amount for all pixels
                const burnAmount = totalCost * Math.pow(10, CONFIG.TOKEN_DECIMALS);
                const transaction = new solanaWeb3.Transaction();
                
                const burnInstruction = createBurnInstruction(
                    tokenAccount.pubkey,
                    mintPubkey,
                    walletPublicKey,
                    burnAmount
                );
                
                transaction.add(burnInstruction);

                const { blockhash } = await connection.getLatestBlockhash();
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = walletPublicKey;

                showLoading(`Approve ${totalCost.toLocaleString()} $MDH burn...`);

                let signature;
                
                // Try signAndSendTransaction first (some wallets prefer this)
                if (walletProvider.signAndSendTransaction) {
                    try {
                        const result = await walletProvider.signAndSendTransaction(transaction);
                        signature = result.signature || result;
                    } catch (e) {
                        // Fallback to signTransaction
                        const signed = await walletProvider.signTransaction(transaction);
                        showLoading('Sending...');
                        signature = await connection.sendRawTransaction(signed.serialize());
                    }
                } else {
                    // Use signTransaction
                    const signed = await walletProvider.signTransaction(transaction);
                    showLoading('Sending...');
                    signature = await connection.sendRawTransaction(signed.serialize());
                }
                
                showLoading('Confirming...');
                await connection.confirmTransaction(signature, 'confirmed');

                // Update state for all selected pixels
                const paintedPixels = [...selectedPixels];
                const paintedColor = selectedColor;
                
                paintedPixels.forEach(p => {
                    canvasState[p.y * CONFIG.CANVAS_SIZE + p.x] = paintedColor;
                });
                
                stats.pixelsPainted += pixelCount;
                stats.tokensBurned += totalCost;
                
                // Save all pixels to database
                await saveMultiplePixels(paintedPixels, paintedColor, signature);
                updateStats();

                // Clear selection
                selectedPixels = [];
                updateSelectionUI();
                
                renderCanvas();
                hideLoading();
                showToast(`${pixelCount} pixel${pixelCount > 1 ? 's' : ''} painted!`, 'success');

            } catch (err) {
                hideLoading();
                console.error('Paint error:', err);
                
                const msg = err.message || String(err);
                if (msg.includes('User rejected') || msg.includes('cancelled') || msg.includes('denied')) {
                    showToast('Cancelled', 'error');
                } else if (msg.includes('insufficient')) {
                    showToast('Insufficient balance', 'error');
                } else if (msg.includes('blockhash')) {
                    showToast('Transaction expired, try again', 'error');
                } else {
                    showToast('Transaction failed: ' + msg.slice(0, 50), 'error');
                }
            }
        }

        function createBurnInstruction(account, mint, owner, amount) {
            const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
            
            // Create data buffer: 1 byte instruction + 8 bytes amount (little endian)
            const data = new Uint8Array(9);
            data[0] = 8; // Burn instruction index
            
            // Write amount as little-endian u64
            const amountBigInt = BigInt(amount);
            for (let i = 0; i < 8; i++) {
                data[1 + i] = Number((amountBigInt >> BigInt(i * 8)) & BigInt(0xff));
            }
            
            return new solanaWeb3.TransactionInstruction({
                keys: [
                    { pubkey: account, isSigner: false, isWritable: true },
                    { pubkey: mint, isSigner: false, isWritable: true },
                    { pubkey: owner, isSigner: true, isWritable: false },
                ],
                programId: TOKEN_PROGRAM_ID,
                data,
            });
        }

        // ═══════════════════════════════════════════
        // STATE PERSISTENCE (Supabase)
        // ═══════════════════════════════════════════
        async function saveCanvasState(x, y, color, txSignature) {
            console.log('Saving pixel:', { x, y, color, txSignature, db: !!db });
            
            if (!db) {
                console.log('No db, using localStorage');
                localStorage.setItem('mdh_canvas', JSON.stringify({ canvas: canvasState, stats }));
                return;
            }
            
            try {
                // Save pixel to database
                const { data: pixelData, error: pixelError } = await db.from('pixels').upsert({
                    id: y * CONFIG.CANVAS_SIZE + x,
                    x, y, color,
                    wallet: walletPublicKey?.toString(),
                    tx_signature: txSignature,
                    updated_at: new Date().toISOString()
                });
                
                if (pixelError) {
                    console.error('Pixel save error:', pixelError);
                    showToast('Error saving pixel: ' + pixelError.message, 'error');
                } else {
                    console.log('Pixel saved:', pixelData);
                }
                
                // Update stats
                const { error: statsError } = await db.from('stats').upsert({
                    id: 1,
                    pixels_painted: stats.pixelsPainted,
                    tokens_burned: stats.tokensBurned
                });
                
                if (statsError) {
                    console.error('Stats save error:', statsError);
                }
            } catch (err) {
                console.error('Save error:', err);
                showToast('Save failed', 'error');
            }
        }
        
        async function saveMultiplePixels(pixels, color, txSignature) {
            console.log('Saving multiple pixels:', { count: pixels.length, color, txSignature, db: !!db });
            
            if (!db) {
                console.log('No db, using localStorage');
                localStorage.setItem('mdh_canvas', JSON.stringify({ canvas: canvasState, stats }));
                return;
            }
            
            try {
                // Prepare batch of pixels
                const pixelsToInsert = pixels.map(p => ({
                    id: p.y * CONFIG.CANVAS_SIZE + p.x,
                    x: p.x,
                    y: p.y,
                    color,
                    wallet: walletPublicKey?.toString(),
                    tx_signature: txSignature,
                    updated_at: new Date().toISOString()
                }));
                
                // Batch upsert all pixels
                const { error: pixelError } = await db.from('pixels').upsert(pixelsToInsert);
                
                if (pixelError) {
                    console.error('Pixels save error:', pixelError);
                    showToast('Error saving pixels: ' + pixelError.message, 'error');
                } else {
                    console.log('Pixels saved:', pixels.length);
                }
                
                // Update stats
                const { error: statsError } = await db.from('stats').upsert({
                    id: 1,
                    pixels_painted: stats.pixelsPainted,
                    tokens_burned: stats.tokensBurned
                });
                
                if (statsError) {
                    console.error('Stats save error:', statsError);
                }
            } catch (err) {
                console.error('Save error:', err);
                showToast('Save failed', 'error');
            }
        }

        async function loadCanvasState() {
            // Always render canvas first
            renderCanvas();
            
            console.log('loadCanvasState called, db:', !!db);
            
            if (!db) {
                console.warn('No database connection, using localStorage');
                try {
                    const saved = JSON.parse(localStorage.getItem('mdh_canvas') || '{}');
                    if (saved.canvas) { canvasState = saved.canvas; stats = saved.stats || stats; }
                    updateStats();
                    renderCanvas();
                } catch (err) {
                    console.warn('localStorage load failed:', err);
                }
                return;
            }
            
            try {
                console.log('Loading pixels from Supabase...');
                
                // Load all pixels (increase limit for large canvas)
                const { data: pixels, error: pixelsError } = await db
                    .from('pixels')
                    .select('x, y, color')
                    .limit(10000);
                
                if (pixelsError) {
                    console.error('Supabase pixels error:', pixelsError);
                    showToast('Error loading pixels', 'error');
                } else if (pixels && pixels.length > 0) {
                    console.log('Loaded pixels:', pixels.length);
                    pixels.forEach(p => {
                        if (p.x >= 0 && p.x < CONFIG.CANVAS_SIZE && p.y >= 0 && p.y < CONFIG.CANVAS_SIZE) {
                            canvasState[p.y * CONFIG.CANVAS_SIZE + p.x] = p.color;
                        }
                    });
                } else {
                    console.log('No pixels found in database');
                }
                
                // Load stats
                const { data: statsData, error: statsError } = await db
                    .from('stats')
                    .select('*')
                    .eq('id', 1)
                    .single();
                
                if (!statsError && statsData) {
                    stats.pixelsPainted = statsData.pixels_painted || 0;
                    stats.tokensBurned = statsData.tokens_burned || 0;
                }
                
                updateStats();
                renderCanvas();
            } catch (err) {
                console.error('Supabase load error:', err);
                // Fallback to localStorage
                try {
                    const saved = JSON.parse(localStorage.getItem('mdh_canvas') || '{}');
                    if (saved.canvas) { canvasState = saved.canvas; stats = saved.stats || stats; }
                    updateStats();
                    renderCanvas();
                } catch (e) {}
            }
        }

        function updateStats() {
            document.getElementById('statPixels').textContent = stats.pixelsPainted.toLocaleString();
            document.getElementById('statBurned').textContent = stats.tokensBurned.toLocaleString();
        }

        // Real-time updates (disabled - using polling instead)
        function setupRealtimeUpdates() {
            // Realtime disabled to avoid WebSocket errors
            // Using polling every 10 seconds instead
            console.log('Using polling for updates (realtime disabled)');
        }

        // Poll for updates (fallback)
        setInterval(loadCanvasState, 10000);

        // ═══════════════════════════════════════════
        // UI HELPERS
        // ═══════════════════════════════════════════
        function showLoading(text) {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('show');
        }

        function showToast(message, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast show ${type}`;
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
    </script>
</body>
</html>
